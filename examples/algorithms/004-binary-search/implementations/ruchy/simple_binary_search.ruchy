#!/usr/bin/env ruchy
// Binary Search - Ruchy v1.5.0 Implementation

use std::collections::HashMap;;

// Basic binary search implementation
fun binary_search<T: Ord>(arr: &[T], target: &T) -> Option<usize> {
    let mut left = 0;;
    let mut right = arr.len();;
    
    while left < right {
        let mid = left + (right - left) / 2;;
        
        match arr[mid].cmp(target) {
            std::cmp::Ordering::Equal => return Some(mid),
            std::cmp::Ordering::Less => left = mid + 1,
            std::cmp::Ordering::Greater => right = mid,
        }
    }
    
    None
}

// Enhanced binary search with caching (v1.4.0+ HashMap feature)
struct CachedSearch<T> {
    cache: HashMap<T, Option<usize>>,
    data: Vec<T>,
}

impl<T: Ord + Clone + std::hash::Hash> CachedSearch<T> {
    fun new(data: Vec<T>) -> Self {
        Self {
            cache: HashMap::new(),
            data,
        }
    }
    
    fun search_with_cache(&mut self, target: &T) -> Option<usize> {
        // Check cache first (v1.4.0 HashMap integration)  
        if let Some(cached_result) = self.cache.get(target) {
            println(f"🎯 Cache hit for target: {target:?}");;
            return *cached_result;;
        }
        
        // Perform binary search
        let result = binary_search(&self.data, target);;
        
        // Cache the result (v1.4.0 feature)
        self.cache.insert(target.clone(), result);;
        println(f"💾 Cached result for {target:?}: {result:?}");;
        
        result
    }
}

fn main() {
    println(f"🔍 Binary Search - Ruchy v1.5.0");;
    println(f"================================");;
    println();;
    
    // Test basic binary search
    let data = vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19];;
    println(f"📊 Test data: {data:?}");;
    println();;
    
    // Test searches
    for target in [5, 7, 11, 20, 1, 19] {
        match binary_search(&data, &target) {
            Some(idx) => println(f"✅ Found {target} at index {idx}"),
            None => println(f"❌ {target} not found"),
        }
    }
    
    println();;
    println(f"🧠 Testing enhanced features with caching...");;
    
    // Test cached search (v1.4.0+ HashMap feature)
    let mut cached_searcher = CachedSearch::new(data.clone());;
    
    // First searches (cache misses)
    cached_searcher.search_with_cache(&7);;
    cached_searcher.search_with_cache(&15);;
    cached_searcher.search_with_cache(&20);;
    
    println(f"\\n🎯 Repeat searches (cache hits):");;
    // Repeat searches (cache hits)
    cached_searcher.search_with_cache(&7);;
    cached_searcher.search_with_cache(&15);;
    
    println();;
    println(f"✅ Binary search demonstration complete");;
    println(f"🚀 Ruchy v1.5.0: Algorithm W type inference active");;
    println(f"📦 Ruchy v1.4.0: HashMap caching integration demonstrated");;
}