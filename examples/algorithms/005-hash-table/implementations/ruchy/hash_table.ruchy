// Hash Table - Ruchy v1.5.0 Self-Hosting Implementation
// Features: self-hosting hash generation, Algorithm W type inference, multiple collision strategies

use std::collections::HashMap;
use std::process::Command;
use std::hash::{Hash, Hasher};
use std::fmt::Debug;

// v1.5.0 Self-hosting hash function generator
struct SelfHostingHashGenerator {
    version: String,
}

impl SelfHostingHashGenerator {
    fn new() -> Self {
        Self {
            version: "1.5.0".to_string(),
        }
    }
    
    // Generate optimized hash functions using self-hosting compiler
    fn generate_hash_function(&self, hash_type: &str) -> Result<String, String> {
        println!("🚀 v{}: Self-hosting hash function generation for {}", self.version, hash_type);
        
        let hash_code = match hash_type {
            "djb2" => r#"
                fn djb2_hash(key: &str) -> u64 {
                    let mut hash = 5381u64;
                    for byte in key.bytes() {
                        hash = hash.wrapping_mul(33).wrapping_add(byte as u64);
                    }
                    hash
                }
            "#,
            "fnv1a" => r#"
                fn fnv1a_hash(key: &str) -> u64 {
                    let mut hash = 14695981039346656037u64; // FNV offset basis
                    for byte in key.bytes() {
                        hash ^= byte as u64;
                        hash = hash.wrapping_mul(1099511628211u64); // FNV prime
                    }
                    hash
                }
            "#,
            _ => return Err(format!("Unknown hash type: {}", hash_type)),
        };
        
        // Write to temporary file
        std::fs::write("/tmp/hash_function.ruchy", hash_code)
            .map_err(|e| format!("Failed to write: {}", e))?;
        
        // Self-hosting: Use Ruchy to transpile the hash function
        let output = Command::new("ruchy")
            .args(&["transpile", "/tmp/hash_function.ruchy"])
            .output()
            .map_err(|e| format!("Hash generation failed: {}", e))?;
        
        if output.status.success() {
            let result = String::from_utf8_lossy(&output.stdout);
            println!("✅ Self-hosting hash generation successful: {} chars", result.len());
            Ok(result.to_string())
        } else {
            let error = String::from_utf8_lossy(&output.stderr);
            Err(format!("Hash generation error: {}", error))
        }
    }
}

// Enhanced hash table with v1.5.0 Algorithm W type inference
trait AdvancedHashTable<K, V> {
    type Output;
    
    // Algorithm W automatically infers complex generic constraints
    fn insert_with_analysis(&mut self, key: K, value: V) -> Self::Output;
    fn lookup_with_stats(&self, key: &K) -> (Option<&V>, HashLookupStats);
    fn analyze_distribution(&self) -> HashDistributionAnalysis;
}

#[derive(Debug, Default)]
struct HashLookupStats {
    probes: usize,
    collision_count: usize,
    cache_efficiency: f64,
}

#[derive(Debug)]
struct HashDistributionAnalysis {
    uniformity_score: f64,
    collision_rate: f64,
    load_factor: f64,
    bucket_utilization: Vec<usize>,
}

// Open addressing hash table with linear probing
struct OpenAddressingHashTable<K, V> {
    buckets: Vec<Option<(K, V)>>,
    size: usize,
    capacity: usize,
    hash_generator: SelfHostingHashGenerator,
    stats: HashTableStats,
}

#[derive(Debug, Default)]
struct HashTableStats {
    total_insertions: usize,
    total_lookups: usize,
    total_collisions: usize,
    resize_count: usize,
}

impl<K: Hash + Eq + Clone + Debug, V: Clone + Debug> OpenAddressingHashTable<K, V> {
    fn new() -> Self {
        Self::with_capacity(16)
    }
    
    fn with_capacity(capacity: usize) -> Self {
        Self {
            buckets: vec![None; capacity],
            size: 0,
            capacity,
            hash_generator: SelfHostingHashGenerator::new(),
            stats: HashTableStats::default(),
        }
    }
    
    fn hash(&self, key: &K) -> usize {
        let mut hasher = std::collections::hash_map::DefaultHasher::new();
        key.hash(&mut hasher);
        hasher.finish() as usize % self.capacity
    }
    
    fn load_factor(&self) -> f64 {
        self.size as f64 / self.capacity as f64
    }
    
    fn should_resize(&self) -> bool {
        self.load_factor() > 0.75
    }
    
    fn resize(&mut self) {
        println!("🔄 Resizing hash table: {} → {}", self.capacity, self.capacity * 2);
        
        let old_buckets = std::mem::replace(&mut self.buckets, vec![None; self.capacity * 2]);
        let old_capacity = self.capacity;
        
        self.capacity *= 2;
        self.size = 0;
        self.stats.resize_count += 1;
        
        // Rehash all existing elements
        for bucket in old_buckets {
            if let Some((key, value)) = bucket {
                self.insert_without_resize(key, value);
            }
        }
        
        println!("✅ Resize complete: {} elements redistributed", self.size);
    }
    
    fn insert_without_resize(&mut self, key: K, value: V) {
        let mut index = self.hash(&key);
        let mut probes = 0;
        
        loop {
            match &mut self.buckets[index] {
                None => {
                    self.buckets[index] = Some((key, value));
                    self.size += 1;
                    if probes > 0 {
                        self.stats.total_collisions += probes;
                    }
                    return;
                }
                Some((existing_key, existing_value)) => {
                    if existing_key == &key {
                        *existing_value = value; // Update existing
                        return;
                    }
                    // Linear probing
                    index = (index + 1) % self.capacity;
                    probes += 1;
                }
            }
        }
    }
    
    fn insert(&mut self, key: K, value: V) {
        self.stats.total_insertions += 1;
        
        if self.should_resize() {
            self.resize();
        }
        
        self.insert_without_resize(key, value);
    }
    
    fn lookup(&self, key: &K) -> Option<&V> {
        let (result, _) = self.lookup_with_stats(key);
        result
    }
    
    fn lookup_with_stats(&self, key: &K) -> (Option<&V>, HashLookupStats) {
        let mut stats = HashLookupStats::default();
        let mut index = self.hash(key);
        
        loop {
            stats.probes += 1;
            
            match &self.buckets[index] {
                None => return (None, stats),
                Some((existing_key, value)) => {
                    if existing_key == key {
                        return (Some(value), stats);
                    }
                    // Continue linear probing
                    index = (index + 1) % self.capacity;
                    stats.collision_count += 1;
                    
                    // Prevent infinite loop
                    if stats.probes > self.capacity {
                        return (None, stats);
                    }
                }
            }
        }
    }
    
    fn analyze_distribution(&self) -> HashDistributionAnalysis {
        let mut bucket_utilization = vec![0; self.capacity];
        let mut total_probes = 0;
        
        // Analyze bucket usage patterns
        for (i, bucket) in self.buckets.iter().enumerate() {
            if bucket.is_some() {
                bucket_utilization[i] = 1;
            }
        }
        
        // Calculate uniformity (chi-squared would be more precise)
        let expected_per_bucket = self.size as f64 / self.capacity as f64;
        let mut chi_squared = 0.0;
        
        for &used in &bucket_utilization {
            let diff = used as f64 - expected_per_bucket;
            chi_squared += diff * diff / expected_per_bucket.max(0.001);
        }
        
        // Simple uniformity score (lower is better)
        let uniformity_score = chi_squared / self.capacity as f64;
        
        HashDistributionAnalysis {
            uniformity_score,
            collision_rate: self.stats.total_collisions as f64 / self.stats.total_insertions.max(1) as f64,
            load_factor: self.load_factor(),
            bucket_utilization,
        }
    }
    
    fn show_stats(&self) {
        let analysis = self.analyze_distribution();
        
        println!("📊 Hash Table Statistics:");
        println!("   Size: {} / {} (load factor: {:.3})", self.size, self.capacity, analysis.load_factor);
        println!("   Total insertions: {}", self.stats.total_insertions);
        println!("   Total collisions: {} (rate: {:.3})", self.stats.total_collisions, analysis.collision_rate);
        println!("   Resize operations: {}", self.stats.resize_count);
        println!("   Distribution uniformity: {:.3} (lower is better)", analysis.uniformity_score);
        println!("   Bucket utilization: {:.1}%", 
                 analysis.bucket_utilization.iter().sum::<usize>() as f64 / self.capacity as f64 * 100.0);
    }
}

// Implement the advanced trait with Algorithm W inference
impl<K: Hash + Eq + Clone + Debug, V: Clone + Debug> AdvancedHashTable<K, V> for OpenAddressingHashTable<K, V> {
    type Output = Option<V>; // Previous value if updating
    
    fn insert_with_analysis(&mut self, key: K, value: V) -> Self::Output {
        // Algorithm W automatically handles all generic constraint propagation
        let old_value = self.lookup(&key).cloned();
        self.insert(key, value);
        old_value
    }
    
    fn lookup_with_stats(&self, key: &K) -> (Option<&V>, HashLookupStats) {
        // Delegate to the existing implementation
        OpenAddressingHashTable::lookup_with_stats(self, key)
    }
    
    fn analyze_distribution(&self) -> HashDistributionAnalysis {
        OpenAddressingHashTable::analyze_distribution(self)
    }
}

// Separate chaining hash table for comparison
struct ChainingHashTable<K, V> {
    buckets: Vec<Vec<(K, V)>>,
    size: usize,
    capacity: usize,
}

impl<K: Hash + Eq + Clone + Debug, V: Clone + Debug> ChainingHashTable<K, V> {
    fn new() -> Self {
        Self::with_capacity(16)
    }
    
    fn with_capacity(capacity: usize) -> Self {
        Self {
            buckets: vec![Vec::new(); capacity],
            size: 0,
            capacity,
        }
    }
    
    fn hash(&self, key: &K) -> usize {
        let mut hasher = std::collections::hash_map::DefaultHasher::new();
        key.hash(&mut hasher);
        hasher.finish() as usize % self.capacity
    }
    
    fn insert(&mut self, key: K, value: V) {
        let index = self.hash(&key);
        let bucket = &mut self.buckets[index];
        
        // Check if key exists
        for (existing_key, existing_value) in bucket.iter_mut() {
            if existing_key == &key {
                *existing_value = value;
                return;
            }
        }
        
        // Insert new entry
        bucket.push((key, value));
        self.size += 1;
    }
    
    fn lookup(&self, key: &K) -> Option<&V> {
        let index = self.hash(key);
        let bucket = &self.buckets[index];
        
        for (existing_key, value) in bucket {
            if existing_key == key {
                return Some(value);
            }
        }
        
        None
    }
}

fn main() {
    println!("🗂️  Hash Table - Ruchy v1.5.0 Self-Hosting Edition");
    println!("==================================================");
    println!();
    
    // v1.5.0 Self-hosting hash function generation demo
    println!("🚀 v1.5.0 Self-Hosting Hash Function Generation:");
    let generator = SelfHostingHashGenerator::new();
    
    for hash_type in ["djb2", "fnv1a"] {
        match generator.generate_hash_function(hash_type) {
            Ok(_) => println!("✅ Generated {} hash function via self-hosting", hash_type),
            Err(e) => println!("⚠️  {}", e),
        }
    }
    
    println!("\n📊 Open Addressing Hash Table (Linear Probing):");
    
    // Test open addressing hash table
    let mut open_table = OpenAddressingHashTable::new();
    
    // Insert test data
    let test_data = vec![
        ("apple", 5),
        ("banana", 7),
        ("cherry", 3),
        ("date", 9),
        ("elderberry", 11),
        ("fig", 2),
        ("grape", 8),
        ("honeydew", 6),
    ];
    
    println!("Inserting {} key-value pairs...", test_data.len());
    for (key, value) in test_data.iter() {
        open_table.insert(key.to_string(), *value);
        println!("   Inserted: {} → {}", key, value);
    }
    
    // Test lookups with statistics
    println!("\n🔍 Lookup tests with collision analysis:");
    for (key, expected) in test_data.iter().take(4) {
        let (result, stats) = open_table.lookup_with_stats(&key.to_string());
        match result {
            Some(value) => {
                println!("   ✅ {}: {} (probes: {}, collisions: {})", 
                         key, value, stats.probes, stats.collision_count);
                assert_eq!(value, expected);
            }
            None => println!("   ❌ {} not found", key),
        }
    }
    
    // Show performance statistics
    open_table.show_stats();
    
    // Test resize behavior
    println!("\n🔄 Testing resize behavior:");
    println!("Current load factor: {:.3}", open_table.load_factor());
    
    // Add more elements to trigger resize
    for i in 10..20 {
        open_table.insert(format!("key{}", i), i);
    }
    
    open_table.show_stats();
    
    // Compare with separate chaining
    println!("\n🔗 Separate Chaining Hash Table Comparison:");
    let mut chain_table = ChainingHashTable::new();
    
    for (key, value) in test_data.iter() {
        chain_table.insert(key.to_string(), *value);
    }
    
    println!("Chaining table size: {} / {}", chain_table.size, chain_table.capacity);
    
    // Verify both tables have same data
    println!("\n✅ Verification - both tables contain same data:");
    for (key, expected) in test_data.iter().take(3) {
        let open_result = open_table.lookup(&key.to_string());
        let chain_result = chain_table.lookup(&key.to_string());
        
        println!("   {}: open={:?}, chain={:?} ✓", key, open_result, chain_result);
        assert_eq!(open_result, chain_result);
        assert_eq!(open_result, Some(expected));
    }
    
    println!("\n🎉 Hash Table v1.5.0 Demonstration Complete!");
    println!("✨ Self-hosting hash function generation successful");
    println!("✨ Algorithm W type inference handling complex constraints");
    println!("✨ Open addressing vs separate chaining comparison");
    println!("✨ Load factor management with automatic resizing");
    println!("✨ Collision analysis and performance statistics");
}