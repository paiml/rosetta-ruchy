#!/usr/bin/env ruchy

use std::vec::Vec
use std::cmp::Ordering
use std::thread
use std::sync::Arc
use std::collections::HashMap
use std::time::Instant

// Performance tracking with HashMap (v1.4.0 feature)
let mut performance_stats: HashMap<String, f64> = HashMap::new()

trait Sortable<T> {
    fun sort(&mut self)
    fun is_sorted(&self) -> bool
    fun benchmark(&mut self, name: &str) -> f64
}

impl<T: Ord + Clone> Sortable<T> for Vec<T> {
    fun sort(&mut self) {
        let len = self.len()
        if len > 1 {
            quicksort_range(self, 0, len - 1)
        }
    }
    
    fun is_sorted(&self) -> bool {
        self.windows(2).all(|w| w[0] <= w[1])
    }
    
    fun benchmark(&mut self, name: &str) -> f64 {
        let start = Instant::now()
        self.sort()
        let duration = start.elapsed().as_secs_f64() * 1000.0
        performance_stats.insert(name.to_string(), duration)
        duration
    }
}

fun quicksort<T: Ord + Clone>(arr: &mut [T]) {
    let len = arr.len()
    if len > 1 {
        quicksort_range(arr, 0, len - 1)
    }
}

fun quicksort_range<T: Ord + Clone>(arr: &mut [T], low: usize, high: usize) {
    if low < high {
        let pivot_index = partition(arr, low, high)
        
        if pivot_index > 0 && pivot_index - 1 >= low {
            quicksort_range(arr, low, pivot_index - 1)
        }
        if pivot_index + 1 <= high {
            quicksort_range(arr, pivot_index + 1, high)
        }
    }
}

fun partition<T: Ord + Clone>(arr: &mut [T], low: usize, high: usize) -> usize {
    let pivot = arr[high].clone()
    let mut i = low
    
    for j in low..high {
        if arr[j] <= pivot {
            arr.swap(i, j)
            i += 1
        }
    }
    
    arr.swap(i, high)
    i
}

// Updated with v1.4.0 method chaining and HashMap
fun quicksort_functional<T: Ord + Clone>(arr: Vec<T>) -> Vec<T> {
    match arr.len() {
        0 | 1 => arr,
        _ => {
            let pivot = arr[arr.len() / 2].clone()
            
            // v1.4.0 method chaining syntax
            let less = arr.iter()
                .filter(|&&x| x < pivot)
                .cloned()
                .collect::<Vec<_>>()
            
            let equal = arr.iter()
                .filter(|&&x| x == pivot)
                .cloned()
                .collect::<Vec<_>>()
            
            let greater = arr.iter()
                .filter(|&&x| x > pivot)
                .cloned()
                .collect::<Vec<_>>()
            
            [
                quicksort_functional(less),
                equal,
                quicksort_functional(greater)
            ].concat()
        }
    }
}

fun quicksort_three_way<T: Ord + Clone>(arr: &mut [T]) {
    if arr.len() <= 1 {
        return
    }
    three_way_partition_sort(arr, 0, arr.len() - 1)
}

fun three_way_partition_sort<T: Ord + Clone>(arr: &mut [T], low: usize, high: usize) {
    if low >= high {
        return
    }
    
    let pivot = arr[low].clone()
    let mut lt = low
    let mut gt = high
    let mut i = low + 1
    
    while i <= gt {
        match arr[i].cmp(&pivot) {
            Ordering::Less => {
                arr.swap(i, lt)
                lt += 1
                i += 1
            }
            Ordering::Greater => {
                arr.swap(i, gt)
                gt -= 1
            }
            Ordering::Equal => {
                i += 1
            }
        }
    }
    
    if lt > 0 {
        three_way_partition_sort(arr, low, lt - 1)
    }
    three_way_partition_sort(arr, gt + 1, high)
}

fun quicksort_parallel<T: Ord + Clone + Send + Sync + 'static>(arr: Vec<T>) -> Vec<T> {
    const PARALLEL_THRESHOLD: usize = 10000
    
    if arr.len() <= PARALLEL_THRESHOLD {
        quicksort_functional(arr)
    } else {
        match arr.len() {
            0 | 1 => arr,
            _ => {
                let pivot = arr[arr.len() / 2].clone()
                let arr = Arc::new(arr)
                
                let arr_clone1 = Arc::clone(&arr)
                let arr_clone2 = Arc::clone(&arr)
                
                let handle_less = thread::spawn(move || {
                    // v1.4.0 method chaining
                    let less = arr_clone1.iter()
                        .filter(|&&x| x < pivot)
                        .cloned()
                        .collect::<Vec<_>>()
                    quicksort_parallel(less)
                })
                
                let handle_greater = thread::spawn(move || {
                    let greater = arr_clone2.iter()
                        .filter(|&&x| x > pivot)
                        .cloned()
                        .collect::<Vec<_>>()
                    quicksort_parallel(greater)
                })
                
                let equal = arr.iter()
                    .filter(|&&x| x == pivot)
                    .cloned()
                    .collect::<Vec<_>>()
                
                let sorted_less = handle_less.join().unwrap()
                let sorted_greater = handle_greater.join().unwrap()
                
                [sorted_less, equal, sorted_greater].concat()
            }
        }
    }
}

// v1.4.0 fat arrow lambda syntax demonstration
fun quicksort_with_custom_comparator<T: Clone>(arr: Vec<T>, compare: fn(&T, &T) -> Ordering) -> Vec<T> {
    match arr.len() {
        0 | 1 => arr,
        _ => {
            let pivot = arr[arr.len() / 2].clone()
            
            let less = arr.iter()
                .filter(|&x| compare(x, &pivot) == Ordering::Less)
                .cloned()
                .collect::<Vec<_>>()
            
            let equal = arr.iter()
                .filter(|&x| compare(x, &pivot) == Ordering::Equal)
                .cloned()
                .collect::<Vec<_>>()
            
            let greater = arr.iter()
                .filter(|&x| compare(x, &pivot) == Ordering::Greater)
                .cloned()
                .collect::<Vec<_>>()
            
            [
                quicksort_with_custom_comparator(less, compare),
                equal,
                quicksort_with_custom_comparator(greater, compare)
            ].concat()
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*
    
    #[test]
    fun test_empty_array() {
        let mut arr: Vec<i32> = vec![]
        quicksort(&mut arr)
        assert_eq!(arr, vec![])
    }
    
    #[test]
    fun test_single_element() {
        let mut arr = vec![42]
        quicksort(&mut arr)
        assert_eq!(arr, vec![42])
    }
    
    #[test]
    fun test_sorted_array() {
        let mut arr = vec![1, 2, 3, 4, 5]
        quicksort(&mut arr)
        assert_eq!(arr, vec![1, 2, 3, 4, 5])
    }
    
    #[test]
    fun test_reverse_array() {
        let mut arr = vec![5, 4, 3, 2, 1]
        quicksort(&mut arr)
        assert_eq!(arr, vec![1, 2, 3, 4, 5])
    }
    
    #[test]
    fun test_random_array() {
        let mut arr = vec![3, 1, 4, 1, 5, 9, 2, 6]
        quicksort(&mut arr)
        assert_eq!(arr, vec![1, 1, 2, 3, 4, 5, 6, 9])
    }
    
    // v1.4.0 HashMap integration test
    #[test]
    fun test_performance_tracking() {
        let mut arr = vec![5, 4, 3, 2, 1]
        let duration = arr.benchmark("reverse_sort")
        assert!(duration > 0.0)
        assert!(performance_stats.contains_key("reverse_sort"))
    }
    
    #[test]
    fun test_custom_comparator() {
        let arr = vec![3, 1, 4, 1, 5, 9, 2, 6]
        
        // Normal comparison
        let sorted_asc = quicksort_with_custom_comparator(arr.clone(), |a, b| a.cmp(b))
        assert_eq!(sorted_asc, vec![1, 1, 2, 3, 4, 5, 6, 9])
        
        // Reverse comparison using fat arrow (v1.4.0)
        let sorted_desc = quicksort_with_custom_comparator(arr, |a, b| b.cmp(a))
        assert_eq!(sorted_desc, vec![9, 6, 5, 4, 3, 2, 1, 1])
    }
    
    #[property_test(10000)]
    fun prop_sorted_has_same_elements(arr: Vec<i32>) {
        let mut sorted = arr.clone()
        quicksort(&mut sorted)
        
        let mut orig_sorted = arr.clone()
        orig_sorted.sort()
        
        assert_eq!(sorted, orig_sorted)
    }
    
    #[property_test(10000)]
    fun prop_sorted_is_ordered(arr: Vec<i32>) {
        let mut sorted = arr.clone()
        quicksort(&mut sorted)
        
        for window in sorted.windows(2) {
            assert!(window[0] <= window[1])
        }
    }
}

// v1.4.0 f-string interpolation showcase
fun display_performance_report() {
    println("ðŸ“Š Performance Report")
    println("====================")
    
    for (algorithm, duration) in &performance_stats {
        println(f"â€¢ {algorithm}: {duration:.2}ms")
    }
    
    if !performance_stats.is_empty() {
        let avg_time = performance_stats.values().sum::<f64>() / performance_stats.len() as f64
        println(f"\nAverage execution time: {avg_time:.2}ms")
    }
}

fun main() {
    let test_arrays = vec![
        vec![],
        vec![42],
        vec![3, 1, 4, 1, 5, 9, 2, 6],
        vec![5, 4, 3, 2, 1],
        vec![1, 2, 3, 4, 5],
        vec![5, 5, 5, 5, 5],
    ]
    
    println("ðŸš€ Quicksort v1.4.0 Feature Showcase")
    println("====================================")
    println()
    
    for (i, arr) in test_arrays.iter().enumerate() {
        // v1.4.0 f-string interpolation
        println(f"Test case {i + 1}: {arr:?}")
        
        let mut arr1 = arr.clone()
        quicksort(&mut arr1)
        println(f"  In-place:    {arr1:?}")
        
        let arr2 = quicksort_functional(arr.clone())
        println(f"  Functional:  {arr2:?}")
        
        let mut arr3 = arr.clone()
        quicksort_three_way(&mut arr3)
        println(f"  Three-way:   {arr3:?}")
        
        if arr.len() > 0 {
            let arr4 = quicksort_parallel(arr.clone())
            println(f"  Parallel:    {arr4:?}")
        }
        
        println()
    }
    
    println("ðŸŽ¯ v1.4.0 Features Demonstration:")
    println()
    
    // Method chaining demonstration
    let large_array: Vec<i32> = (0..10000)
        .map(|i| (i * 37 + 11) % 1000)
        .collect()
    
    println(f"Generated array of {large_array.len()} elements")
    
    // Performance tracking with HashMap
    let mut test_arr = large_array.clone()
    let duration = test_arr.benchmark("large_array_sort")
    println(f"Sort completed in {duration:.2}ms")
    
    // Custom comparator with fat arrow
    let sample = vec![5, 2, 8, 1, 9, 3]
    let desc_sorted = quicksort_with_custom_comparator(sample.clone(), |a, b| b.cmp(a))
    println(f"Descending sort: {sample:?} â†’ {desc_sorted:?}")
    
    // Display performance report
    display_performance_report()
    
    println()
    println("âœ… v1.4.0 features successfully demonstrated!")
    println(f"HashMap integration: {performance_stats.len()} entries tracked")
    println("Method chaining: Enabled for Vec transformations")
    println("F-string interpolation: Working in all contexts")
}