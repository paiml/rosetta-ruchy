[metadata]
name = "quicksort"
category = "sorting"
difficulty = "medium"
tags = ["divide-conquer", "recursion", "in-place", "comparison-sort"]

[complexity]
time_average = "O(n log n)"
time_worst = "O(nÂ²)"
space = "O(log n)"
stable = false

[test_cases.basic]
empty = { input = [], expected = [] }
single = { input = [42], expected = [42] }
sorted = { input = [1, 2, 3, 4, 5], expected = [1, 2, 3, 4, 5] }
reverse = { input = [5, 4, 3, 2, 1], expected = [1, 2, 3, 4, 5] }
random = { input = [3, 1, 4, 1, 5, 9, 2, 6], expected = [1, 1, 2, 3, 4, 5, 6, 9] }
duplicates = { input = [5, 5, 5, 5, 5], expected = [5, 5, 5, 5, 5] }
mixed = { input = [3, -1, 4, -1, 5, 9, -2, 6], expected = [-2, -1, -1, 3, 4, 5, 6, 9] }

[test_cases.stress]
large_random = { generate = "random", size = 10000, seed = 42 }
large_sorted = { generate = "sorted", size = 10000 }
large_reverse = { generate = "reverse", size = 10000 }
large_duplicates = { generate = "duplicates", size = 10000, distinct = 10 }

[benchmark]
iterations = 1000
warmup = 100
sizes = [100, 1000, 10000, 100000]
patterns = ["random", "sorted", "reverse", "duplicates"]

[performance_targets]
"10000_elements_ms" = 2.0
"100000_elements_ms" = 25.0
"1000000_elements_ms" = 300.0
memory_overhead_percent = 10.0

[validation]
property_tests = 10000
mutation_score = 0.85
coverage_percent = 95.0