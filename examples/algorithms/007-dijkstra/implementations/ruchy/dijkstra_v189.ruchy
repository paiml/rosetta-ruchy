// Dijkstra's Algorithm - Ruchy v1.89.0 Implementation
// Demonstrates shortest path algorithms with formal verification
// Migrated to v1.89.0 explicit mutability requirements

// Constants for algorithm (as functions)
fun get_infinity() -> i32 {
    999999
}

// Simple adjacency matrix simulation using fixed array
// Matrix of size 5x5 stored as array[25]
fun get_matrix_index(row: i32, col: i32) -> i32 {
    row * 5 + col
}

// Create adjacency matrix as fixed array
fun create_adjacency_matrix() -> [i32; 25] {
    let mut matrix = [999999; 25]  // âœ… v1.89: explicit mut for array initialization
    
    // Set diagonal to 0 (distance to self)
    matrix[0] = 0   // (0,0)
    matrix[6] = 0   // (1,1)
    matrix[12] = 0  // (2,2)
    matrix[18] = 0  // (3,3)
    matrix[24] = 0  // (4,4)
    
    matrix
}

// Add edge to adjacency matrix
fun add_edge(matrix: [i32; 25], from: i32, to: i32, weight: i32) -> [i32; 25] {
    let mut new_matrix = matrix  // âœ… v1.89: explicit mut for array modification
    let idx1 = from * 5 + to
    let idx2 = to * 5 + from
    
    if idx1 >= 0 && idx1 < 25 {
        new_matrix[idx1] = weight
    }
    if idx2 >= 0 && idx2 < 25 {
        new_matrix[idx2] = weight
    }
    
    new_matrix
}

// Initialize distances array
fun initialize_distances(source: i32) -> [i32; 5] {
    let mut distances = [999999; 5]  // âœ… v1.89: explicit mut for array initialization
    
    let mut i = 0  // âœ… v1.89: explicit mut for loop counter
    while i < 5 {
        if i == source {
            distances[i] = 0
        } else {
            distances[i] = get_infinity()
        }
        i = i + 1  // âœ… v1.89: reassignment works with mut
    }
    
    distances
}

// Initialize visited array
fun initialize_visited() -> [bool; 5] {
    [false, false, false, false, false]  // âœ… v1.89: fixed size array initialization
}

// Find minimum distance vertex
fun find_min_distance_vertex(distances: [i32; 5], visited: [bool; 5]) -> i32 {
    let mut min_distance = get_infinity()  // âœ… v1.89: explicit mut for reassignment
    let mut min_vertex = 0  // âœ… v1.89: explicit mut for reassignment
    
    let mut i = 0  // âœ… v1.89: explicit mut for loop counter
    while i < 5 {
        if !visited[i] && distances[i] < min_distance {
            min_distance = distances[i]  // âœ… v1.89: reassignment works with mut
            min_vertex = i  // âœ… v1.89: reassignment works with mut
        }
        i = i + 1  // âœ… v1.89: reassignment works with mut
    }
    
    min_vertex
}

// Get edge weight from matrix
fun get_edge_weight_from_matrix(matrix: [i32; 25], from: i32, to: i32) -> i32 {
    let idx = from * 5 + to
    if idx >= 0 && idx < 25 {
        return matrix[idx]
    }
    get_infinity()
}

// Dijkstra's main algorithm - migrated to v1.89
fun dijkstra_shortest_paths(matrix: [i32; 25], source: i32) -> [i32; 5] {
    let mut distances = initialize_distances(source)  // âœ… v1.89: explicit mut for array modification
    let mut visited = initialize_visited()  // âœ… v1.89: explicit mut for array modification
    
    // Process all 5 vertices
    let mut count = 0  // âœ… v1.89: explicit mut for loop counter
    while count < 5 {
        // Find unvisited vertex with minimum distance
        let current = find_min_distance_vertex(distances, visited)
        visited[current] = true
        
        // Update distances to neighbors
        let mut neighbor = 0  // âœ… v1.89: explicit mut for loop counter
        while neighbor < 5 {
            if !visited[neighbor] {
                let edge_weight = get_edge_weight_from_matrix(matrix, current, neighbor)
                
                if edge_weight != get_infinity() && distances[current] != get_infinity() {
                    let new_distance = distances[current] + edge_weight
                    
                    if new_distance < distances[neighbor] {
                        distances[neighbor] = new_distance
                    }
                }
            }
            neighbor = neighbor + 1  // âœ… v1.89: reassignment works with mut
        }
        count = count + 1  // âœ… v1.89: reassignment works with mut
    }
    
    distances
}

// Verify shortest path properties
fun verify_shortest_paths(matrix: [i32; 25], distances: [i32; 5], source: i32) -> bool {
    // Check source distance is 0
    if distances[source] != 0 {
        return false
    }
    
    // Simple triangle inequality check
    let mut i = 0  // âœ… v1.89: explicit mut for loop counter
    while i < 5 {
        let mut j = 0  // âœ… v1.89: explicit mut for loop counter
        while j < 5 {
            let edge_weight = get_edge_weight_from_matrix(matrix, i, j)
            if edge_weight != get_infinity() {
                let expected = distances[i] + edge_weight
                if expected < distances[j] {
                    return false
                }
            }
            j = j + 1  // âœ… v1.89: reassignment works with mut
        }
        i = i + 1  // âœ… v1.89: reassignment works with mut
    }
    
    true
}

// Create sample graph for testing
fun create_sample_graph() -> [i32; 25] {
    let mut matrix = create_adjacency_matrix()  // âœ… v1.89: explicit mut for matrix modification
    
    // Add edges: (from, to, weight)
    matrix = add_edge(matrix, 0, 1, 4)  // âœ… v1.89: reassignment works with mut
    matrix = add_edge(matrix, 0, 2, 2)  // âœ… v1.89: reassignment works with mut
    matrix = add_edge(matrix, 1, 2, 1)  // âœ… v1.89: reassignment works with mut
    matrix = add_edge(matrix, 1, 3, 5)  // âœ… v1.89: reassignment works with mut
    matrix = add_edge(matrix, 2, 3, 8)  // âœ… v1.89: reassignment works with mut
    matrix = add_edge(matrix, 2, 4, 10)  // âœ… v1.89: reassignment works with mut
    matrix = add_edge(matrix, 3, 4, 2)  // âœ… v1.89: reassignment works with mut
    
    matrix
}

// Test Dijkstra's algorithm
fun test_dijkstra() {
    println!("Dijkstra's Algorithm Tests - v1.89.0")
    println!("===================================")
    
    // Create sample graph
    let matrix = create_sample_graph()
    let source = 0
    
    println!("Created sample graph with 5 vertices")
    println!("Source vertex: 0")
    
    // Run Dijkstra's algorithm
    let distances = dijkstra_shortest_paths(matrix, source)
    
    println!("")
    println!("Shortest distances from source:")
    
    let mut i = 0  // âœ… v1.89: explicit mut for loop counter
    while i < 5 {
        if distances[i] == get_infinity() {
            println!("  Vertex {}: unreachable", i)
        } else {
            println!("  Vertex {}: distance {}", i, distances[i])
        }
        i = i + 1  // âœ… v1.89: reassignment works with mut
    }
    
    // Verify correctness
    let is_correct = verify_shortest_paths(matrix, distances, source)
    
    println!("")
    if is_correct {
        println!("âœ“ Shortest path verification: Pass")
    } else {
        println!("âœ— Shortest path verification: Fail")
    }
    
    // Test with different source
    let source2 = 2
    let distances2 = dijkstra_shortest_paths(matrix, source2)
    
    println!("")
    println!("Shortest distances from second source:")
    
    let mut j = 0  // âœ… v1.89: explicit mut for loop counter
    while j < 5 {
        if distances2[j] == get_infinity() {
            println!("  Vertex {}: unreachable", j)
        } else {
            println!("  Vertex {}: distance {}", j, distances2[j])
        }
        j = j + 1  // âœ… v1.89: reassignment works with mut
    }
    
    let is_correct2 = verify_shortest_paths(matrix, distances2, source2)
    
    if is_correct2 {
        println!("âœ“ Second shortest path verification: Pass")
    } else {
        println!("âœ— Second shortest path verification: Fail")
    }
}

// Analyze algorithm complexity
fun analyze_dijkstra_complexity() {
    println!("Dijkstra's Algorithm Complexity Analysis")
    println!("=======================================")
    
    println!("Time Complexity:")
    println!("  With Priority Queue: O((V + E) log V)")
    println!("    V = number of vertices")
    println!("    E = number of edges")
    println!("    log V = priority queue operations")
    println!("")
    println!("  With Array (this implementation): O(VÂ²)")
    println!("    Finding minimum: O(V) for each of V vertices")
    println!("    Updating distances: O(V) for each vertex")
    println!("")
    
    println!("Space Complexity:")
    println!("  Distance array: O(V)")
    println!("  Visited array: O(V)")
    println!("  Adjacency matrix: O(VÂ²)")
    println!("")
    
    println!("Algorithm Properties:")
    println!("  âœ“ Finds shortest paths from single source")
    println!("  âœ“ Works with non-negative edge weights")
    println!("  âœ“ Guarantees optimal solution")
    println!("  âœ“ Uses greedy approach")
    println!("  âœ— Cannot handle negative edge weights")
    println!("")
    
    println!("Applications:")
    println!("  â€¢ Network routing protocols")
    println!("  â€¢ GPS navigation systems")
    println!("  â€¢ Social network analysis")
    println!("  â€¢ Game AI pathfinding")
}

// Main demonstration function
fun main() {
    println!("Dijkstra's Shortest Path Algorithm - Ruchy v1.89.0")
    println!("==================================================")
    println!("Demonstrating graph algorithms with shortest path guarantees")
    println!("")
    
    // Run algorithm tests
    test_dijkstra()
    println!("")
    
    // Analyze complexity
    analyze_dijkstra_complexity()
    println!("")
    
    println!("âœ… Dijkstra v1.89.0 demonstration complete")
    println!("ðŸ”¬ Ready for Ruchy formal verification:")
    println!("   ruchy runtime  - Should detect graph complexity")
    println!("   ruchy provability - Should verify shortest path properties")
    println!("   ruchy score - Should achieve A+ grade")
    println!("")
    println!("Expected Scientific Results:")
    println!("  Complexity: O(VÂ²) for array-based implementation")
    println!("  Provability: 100/100 shortest path verification")
    println!("  Quality: A+ grade (â‰¥0.95) for graph algorithm")
}