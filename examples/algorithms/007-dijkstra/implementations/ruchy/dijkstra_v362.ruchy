// Dijkstra's Algorithm - Ruchy v3.62.12 Implementation
// Migrated from v1.89.0 using WRAPPER STRUCT pattern
// Breaking Change #1 Solution: Wrap [T; N] in struct types

// Wrapper types for v3.62.12 compatibility
struct Matrix25 {
    data: [i32; 25]
}

struct Distances5 {
    data: [i32; 5]
}

struct Visited5 {
    data: [bool; 5]
}

// Constants for algorithm (as functions)
fun get_infinity() -> i32 {
    999999
}

// Simple adjacency matrix simulation using fixed array
// Matrix of size 5x5 stored as array[25]
fun get_matrix_index(row: i32, col: i32) -> i32 {
    row * 5 + col
}

// Create adjacency matrix as wrapped struct
fun create_adjacency_matrix() -> Matrix25 {
    let mut matrix = [999999; 25]

    // Set diagonal to 0 (distance to self)
    matrix[0] = 0   // (0,0)
    matrix[6] = 0   // (1,1)
    matrix[12] = 0  // (2,2)
    matrix[18] = 0  // (3,3)
    matrix[24] = 0  // (4,4)

    Matrix25 { data: matrix }
}

// Add edge to adjacency matrix
// v3.62.12: Uses Matrix25 wrapper struct
fun add_edge(matrix: Matrix25, from_vertex: i32, to_vertex: i32, weight: i32) -> Matrix25 {
    let mut new_matrix = matrix.data  // Extract array from struct
    let idx1 = from_vertex * 5 + to_vertex
    let idx2 = to_vertex * 5 + from_vertex

    if idx1 >= 0 && idx1 < 25 {
        new_matrix[idx1] = weight
    }
    if idx2 >= 0 && idx2 < 25 {
        new_matrix[idx2] = weight
    }

    Matrix25 { data: new_matrix }  // Wrap result back in struct
}

// Initialize distances array
fun initialize_distances(source: i32) -> Distances5 {
    let mut distances = [999999; 5]

    let mut i = 0
    while i < 5 {
        if i == source {
            distances[i] = 0
        } else {
            distances[i] = get_infinity()
        }
        i = i + 1
    }

    Distances5 { data: distances }
}

// Initialize visited array
fun initialize_visited() -> Visited5 {
    Visited5 {
        data: [false, false, false, false, false]
    }
}

// Find minimum distance vertex
// v3.62.12: Uses wrapper structs for parameters
fun find_min_distance_vertex(distances: Distances5, visited: Visited5) -> i32 {
    let mut min_distance = get_infinity()
    let mut min_vertex = 0

    let mut i = 0
    while i < 5 {
        if !visited.data[i] && distances.data[i] < min_distance {
            min_distance = distances.data[i]
            min_vertex = i
        }
        i = i + 1
    }

    min_vertex
}

// Get edge weight from matrix
// v3.62.12: Uses Matrix25 wrapper struct
fun get_edge_weight_from_matrix(matrix: Matrix25, from_vertex: i32, to_vertex: i32) -> i32 {
    let idx = from_vertex * 5 + to_vertex
    if idx >= 0 && idx < 25 {
        return matrix.data[idx]
    }
    get_infinity()
}

// Dijkstra's main algorithm - migrated to v3.62.12
// v3.62.12: Uses Matrix25 wrapper struct
fun dijkstra_shortest_paths(matrix: Matrix25, source: i32) -> Distances5 {
    let mut distances = initialize_distances(source)
    let mut visited = initialize_visited()

    // Process all 5 vertices
    let mut count = 0
    while count < 5 {
        // Find unvisited vertex with minimum distance
        let current = find_min_distance_vertex(distances, visited)
        visited.data[current] = true

        // Update distances to neighbors
        let mut neighbor = 0
        while neighbor < 5 {
            if !visited.data[neighbor] {
                let edge_weight = get_edge_weight_from_matrix(matrix, current, neighbor)

                if edge_weight != get_infinity() && distances.data[current] != get_infinity() {
                    let new_distance = distances.data[current] + edge_weight

                    if new_distance < distances.data[neighbor] {
                        distances.data[neighbor] = new_distance
                    }
                }
            }
            neighbor = neighbor + 1
        }
        count = count + 1
    }

    distances
}

// Verify shortest path properties
// v3.62.12: Uses wrapper structs
fun verify_shortest_paths(matrix: Matrix25, distances: Distances5, source: i32) -> bool {
    // Check source distance is 0
    if distances.data[source] != 0 {
        return false
    }

    // Simple triangle inequality check
    let mut i = 0
    while i < 5 {
        let mut j = 0
        while j < 5 {
            let edge_weight = get_edge_weight_from_matrix(matrix, i, j)
            if edge_weight != get_infinity() {
                let expected = distances.data[i] + edge_weight
                if expected < distances.data[j] {
                    return false
                }
            }
            j = j + 1
        }
        i = i + 1
    }

    true
}

// Create sample graph for testing
fun create_sample_graph() -> Matrix25 {
    let mut matrix = create_adjacency_matrix()

    // Add edges: (from, to, weight)
    // v3.62.12: Functions accept/return Matrix25 structs
    matrix = add_edge(matrix, 0, 1, 4)
    matrix = add_edge(matrix, 0, 2, 2)
    matrix = add_edge(matrix, 1, 2, 1)
    matrix = add_edge(matrix, 1, 3, 5)
    matrix = add_edge(matrix, 2, 3, 8)
    matrix = add_edge(matrix, 2, 4, 10)
    matrix = add_edge(matrix, 3, 4, 2)

    matrix
}

// Test Dijkstra's algorithm
fun test_dijkstra() {
    println!("Dijkstra's Algorithm Tests - v3.62.12")
    println!("===================================")

    // Create sample graph
    let matrix = create_sample_graph()
    let source = 0

    println!("Created sample graph with 5 vertices")
    println!("Source vertex: 0")

    // Run Dijkstra's algorithm
    let distances = dijkstra_shortest_paths(matrix, source)

    println!("")
    println!("Shortest distances from source:")

    let mut i = 0
    while i < 5 {
        if distances.data[i] == get_infinity() {
            println!("  Vertex {}: unreachable", i)
        } else {
            println!("  Vertex {}: distance {}", i, distances.data[i])
        }
        i = i + 1
    }

    // Verify correctness
    let is_correct = verify_shortest_paths(matrix, distances, source)

    println!("")
    if is_correct {
        println!("âœ“ Shortest path verification: Pass")
    } else {
        println!("âœ— Shortest path verification: Fail")
    }

    // Test with different source
    let source2 = 2
    let distances2 = dijkstra_shortest_paths(matrix, source2)

    println!("")
    println!("Shortest distances from second source:")

    let mut j = 0
    while j < 5 {
        if distances2.data[j] == get_infinity() {
            println!("  Vertex {}: unreachable", j)
        } else {
            println!("  Vertex {}: distance {}", j, distances2.data[j])
        }
        j = j + 1
    }

    let is_correct2 = verify_shortest_paths(matrix, distances2, source2)

    if is_correct2 {
        println!("âœ“ Second shortest path verification: Pass")
    } else {
        println!("âœ— Second shortest path verification: Fail")
    }
}

// Analyze algorithm complexity
fun analyze_dijkstra_complexity() {
    println!("Dijkstra's Algorithm Complexity Analysis")
    println!("=======================================")

    println!("Time Complexity:")
    println!("  With Priority Queue: O((V + E) log V)")
    println!("    V = number of vertices")
    println!("    E = number of edges")
    println!("    log V = priority queue operations")
    println!("")
    println!("  With Array (this implementation): O(VÂ²)")
    println!("    Finding minimum: O(V) for each of V vertices")
    println!("    Updating distances: O(V) for each vertex")
    println!("")

    println!("Space Complexity:")
    println!("  Distance array: O(V)")
    println!("  Visited array: O(V)")
    println!("  Adjacency matrix: O(VÂ²)")
    println!("")

    println!("Algorithm Properties:")
    println!("  âœ“ Finds shortest paths from single source")
    println!("  âœ“ Works with non-negative edge weights")
    println!("  âœ“ Guarantees optimal solution")
    println!("  âœ“ Uses greedy approach")
    println!("  âœ— Cannot handle negative edge weights")
    println!("")

    println!("Applications:")
    println!("  â€¢ Network routing protocols")
    println!("  â€¢ GPS navigation systems")
    println!("  â€¢ Social network analysis")
    println!("  â€¢ Game AI pathfinding")
}

// Main demonstration function
fun main() {
    println!("Dijkstra's Shortest Path Algorithm - Ruchy v3.62.12")
    println!("==================================================")
    println!("Demonstrating graph algorithms with shortest path guarantees")
    println!("")

    // Run algorithm tests
    test_dijkstra()
    println!("")

    // Analyze complexity
    analyze_dijkstra_complexity()
    println!("")

    println!("âœ… Dijkstra v3.62.12 migration complete (WRAPPER STRUCT approach)")
    println!("ðŸ”¬ Ready for Ruchy formal verification:")
    println!("   ruchy check - Syntax validation")
    println!("   ruchy runtime - Graph complexity detection")
    println!("   ruchy provability - Shortest path property verification")
    println!("   ruchy score - Quality assessment")
    println!("")
    println!("Migration Notes:")
    println!("  â€¢ Created wrapper structs: Matrix25, Distances5, Visited5")
    println!("  â€¢ Array parameters wrapped in type-safe structs")
    println!("  â€¢ Access arrays via .data field")
    println!("  â€¢ Algorithm logic unchanged - maintains correctness")
    println!("  â€¢ Workaround for parser bug: &[T; N] fails with 3+ params")
}
