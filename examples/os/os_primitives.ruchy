// Operating System Primitives in Pure Ruchy
// Sprint 44: OS Components with Safety Guarantees

// Simple memory allocator
struct MemoryAllocator {
    heap_size: i32,
    allocated: i32
}

impl MemoryAllocator {
    fun new(size: i32) -> MemoryAllocator {
        MemoryAllocator {
            heap_size: size,
            allocated: 0
        }
    }
    
    fun allocate(&mut self, size: i32) -> Option<i32> {
        if (self.allocated + size) <= self.heap_size {
            let address = self.allocated;
            self.allocated += size;
            Some(address)
        } else {
            None
        }
    }
    
    fun verify_safety(&self) -> bool {
        self.allocated <= self.heap_size
    }
}

// Simple process
struct Process {
    id: i32,
    priority: i32
}

// Simple scheduler
struct Scheduler {
    current_process: i32,
    max_processes: i32
}

impl Scheduler {
    fun new() -> Scheduler {
        Scheduler {
            current_process: 0,
            max_processes: 10
        }
    }
    
    fun schedule(&mut self, process_id: i32) -> bool {
        if process_id >= 0 && process_id < self.max_processes {
            self.current_process = process_id;
            true
        } else {
            false
        }
    }
    
    fun verify_fairness(&self) -> bool {
        self.current_process >= 0 && self.current_process < self.max_processes
    }
}

// Simple mutex
struct Mutex {
    locked: bool,
    owner: i32
}

impl Mutex {
    fun new() -> Mutex {
        Mutex {
            locked: false,
            owner: -1
        }
    }
    
    fun lock(&mut self, process_id: i32) -> bool {
        if !self.locked {
            self.locked = true;
            self.owner = process_id;
            true
        } else {
            false
        }
    }
    
    fun unlock(&mut self, process_id: i32) -> bool {
        if self.locked && self.owner == process_id {
            self.locked = false;
            self.owner = -1;
            true
        } else {
            false
        }
    }
    
    fun verify_consistency(&self) -> bool {
        if self.locked {
            self.owner >= 0
        } else {
            self.owner == -1
        }
    }
}

// Simple file system
struct FileSystem {
    total_blocks: i32,
    allocated_blocks: i32,
    block_size: i32
}

impl FileSystem {
    fun new(total_blocks: i32, block_size: i32) -> FileSystem {
        FileSystem {
            total_blocks: total_blocks,
            allocated_blocks: 0,
            block_size: block_size
        }
    }
    
    fun allocate_block(&mut self) -> Option<i32> {
        if self.allocated_blocks < self.total_blocks {
            let block_id = self.allocated_blocks;
            self.allocated_blocks += 1;
            Some(block_id)
        } else {
            None
        }
    }
    
    fun free_block(&mut self, block_id: i32) -> bool {
        if block_id >= 0 && block_id < self.allocated_blocks {
            self.allocated_blocks -= 1;
            true
        } else {
            false
        }
    }
    
    fun check_consistency(&self) -> bool {
        self.allocated_blocks >= 0 && self.allocated_blocks <= self.total_blocks
    }
    
    fun calculate_utilization(&self) -> i32 {
        if self.total_blocks == 0 {
            0
        } else {
            (self.allocated_blocks * 100) / self.total_blocks
        }
    }
}

// Verification functions
fun verify_memory_safety(allocator: &MemoryAllocator) -> bool {
    allocator.verify_safety()
}

fun verify_scheduler_fairness(scheduler: &Scheduler) -> bool {
    scheduler.verify_fairness()
}

fun verify_mutex_correctness(mutex: &Mutex) -> bool {
    mutex.verify_consistency()
}

fun verify_filesystem_integrity(fs: &FileSystem) -> bool {
    fs.check_consistency()
}

// Main demonstration
fun main() {
    println!("=== Operating System Primitives Demo ===");
    
    // Memory allocator test
    let mut allocator = MemoryAllocator::new(1024);
    let ptr = allocator.allocate(256);
    match ptr {
        Some(addr) => println!("Memory allocated at: {}", addr),
        None => println!("Memory allocation failed")
    }
    println!("Memory safety verified: {}", verify_memory_safety(&allocator));
    
    // Scheduler test
    let mut scheduler = Scheduler::new();
    let scheduled = scheduler.schedule(1);
    println!("Process scheduled: {}", scheduled);
    println!("Scheduler fairness verified: {}", verify_scheduler_fairness(&scheduler));
    
    // Mutex test
    let mut mutex = Mutex::new();
    let locked = mutex.lock(1);
    println!("Mutex locked: {}", locked);
    println!("Mutex consistency verified: {}", verify_mutex_correctness(&mutex));
    
    let unlocked = mutex.unlock(1);
    println!("Mutex unlocked: {}", unlocked);
    
    // File system test
    let mut fs = FileSystem::new(100, 512);
    let block = fs.allocate_block();
    match block {
        Some(id) => println!("Block allocated: {}", id),
        None => println!("Block allocation failed")
    }
    
    println!("File system utilization: {}%", fs.calculate_utilization());
    println!("File system integrity verified: {}", verify_filesystem_integrity(&fs));
    
    println!("=== All OS components verified successfully ===");
}