#!/usr/bin/env ruchy

// Complete Blockchain Security Test Suite - 100% Coverage Target
// Comprehensive security-focused testing for blockchain implementations

use std::collections::HashMap;
use std::time::SystemTime;

// Test module with 100% coverage target
#[test_coverage(target = 100)]
module blockchain_security_tests {
    use super::*;
    
    // ============================================================
    // Proof-of-Work Difficulty Adjustment Tests
    // ============================================================
    
    #[test]
    fun test_difficulty_adjustment_up() {
        // Test difficulty increases when blocks are mined too fast
        let mut blockchain = Blockchain::new();
        let target_time = 600; // 10 minutes in seconds
        
        // Mine blocks faster than target (5 minutes each)
        let mut last_time = SystemTime::now();
        for _ in 0..5 {
            let block_time = last_time + std::time::Duration::from_secs(300); // 5 minutes
            let block = create_test_block(blockchain.get_last_hash(), block_time);
            blockchain.add_block(block);
            last_time = block_time;
        }
        
        // Calculate expected difficulty adjustment
        let actual_time = 300 * 4; // 4 intervals of 5 minutes
        let expected_time = target_time * 4; // 4 intervals of 10 minutes
        let adjustment_factor = expected_time as f64 / actual_time as f64;
        
        // Difficulty should increase
        let new_difficulty = blockchain.adjust_difficulty();
        let old_difficulty = blockchain.get_previous_difficulty();
        
        assert!(new_difficulty > old_difficulty,
            "Difficulty should increase when blocks are mined too fast");
        
        // Check adjustment is proportional (with bounds)
        let actual_factor = new_difficulty as f64 / old_difficulty as f64;
        assert!(actual_factor >= 1.0 && actual_factor <= 4.0,
            "Difficulty adjustment should be bounded");
    }
    
    #[test]
    fun test_difficulty_adjustment_down() {
        // Test difficulty decreases when blocks are mined too slow
        let mut blockchain = Blockchain::new();
        let target_time = 600; // 10 minutes
        
        // Mine blocks slower than target (20 minutes each)
        let mut last_time = SystemTime::now();
        for _ in 0..5 {
            let block_time = last_time + std::time::Duration::from_secs(1200); // 20 minutes
            let block = create_test_block(blockchain.get_last_hash(), block_time);
            blockchain.add_block(block);
            last_time = block_time;
        }
        
        // Difficulty should decrease
        let new_difficulty = blockchain.adjust_difficulty();
        let old_difficulty = blockchain.get_previous_difficulty();
        
        assert!(new_difficulty < old_difficulty,
            "Difficulty should decrease when blocks are mined too slow");
        
        // Should not decrease below minimum
        assert!(new_difficulty >= 1,
            "Difficulty should not go below minimum value");
    }
    
    #[test]
    fun test_difficulty_bounds() {
        // Test difficulty adjustment bounds
        let mut blockchain = Blockchain::new();
        
        // Extreme case: blocks mined instantly
        let now = SystemTime::now();
        for i in 0..5 {
            let block = create_test_block(blockchain.get_last_hash(), 
                now + std::time::Duration::from_secs(i)); // 1 second apart
            blockchain.add_block(block);
        }
        
        let new_difficulty = blockchain.adjust_difficulty();
        let old_difficulty = blockchain.get_previous_difficulty();
        
        // Should not increase by more than 4x
        assert!(new_difficulty <= old_difficulty * 4,
            "Difficulty increase should be bounded by 4x");
        
        // Test extreme slow case
        let mut slow_chain = Blockchain::new();
        let start_time = SystemTime::now();
        for i in 0..5 {
            let block_time = start_time + std::time::Duration::from_secs(86400 * i); // 1 day apart
            let block = create_test_block(slow_chain.get_last_hash(), block_time);
            slow_chain.add_block(block);
        }
        
        let slow_difficulty = slow_chain.adjust_difficulty();
        let slow_old_difficulty = slow_chain.get_previous_difficulty();
        
        // Should not decrease by more than 4x
        assert!(slow_difficulty >= slow_old_difficulty / 4,
            "Difficulty decrease should be bounded by 4x");
    }
    
    // ============================================================
    // Smart Contract Determinism Property Tests
    // ============================================================
    
    #[property_test]
    fun prop_contract_determinism(contract: SmartContract, input: ContractInput) {
        // Property: same input always produces same output
        let result1 = contract.execute(input.clone());
        let result2 = contract.execute(input.clone());
        
        assert_eq!(result1, result2,
            "Smart contract execution must be deterministic");
        
        // Property: execution should not modify contract state in pure functions
        if contract.is_pure_function() {
            let state_before = contract.get_state();
            let _ = contract.execute(input);
            let state_after = contract.get_state();
            
            assert_eq!(state_before, state_after,
                "Pure contract functions should not modify state");
        }
    }
    
    #[test]
    fun test_contract_gas_limits() {
        // Test gas limit enforcement
        let contract = SmartContract::new("
            fun infinite_loop() {
                let mut i = 0;
                while true {
                    i = i + 1;
                }
            }
        ");
        
        let gas_limit = 1000;
        let result = contract.execute_with_gas_limit(
            ContractInput::function_call("infinite_loop", vec![]),
            gas_limit
        );
        
        // Should fail with out of gas error
        assert!(result.is_err(), "Infinite loop should run out of gas");
        assert_eq!(result.unwrap_err(), ContractError::OutOfGas);
        
        // Gas consumption should equal limit
        assert_eq!(contract.get_gas_used(), gas_limit);
    }
    
    #[test]
    fun test_contract_stack_overflow_protection() {
        // Test stack overflow protection
        let contract = SmartContract::new("
            fun recursive_function(n: i32) -> i32 {
                if n <= 0 {
                    return 1;
                }
                return recursive_function(n - 1) + recursive_function(n - 1);
            }
        ");
        
        // Try to cause stack overflow
        let result = contract.execute(
            ContractInput::function_call("recursive_function", vec![Value::Int(1000)])
        );
        
        // Should fail with stack overflow protection
        assert!(result.is_err(), "Deep recursion should be prevented");
        
        // Should not crash the system
        let stack_size = get_current_stack_size();
        assert!(stack_size < MAX_STACK_SIZE,
            "Stack should remain bounded");
    }
    
    #[test]
    fun test_contract_reentrancy_protection() {
        // Test reentrancy attack prevention
        let attacker_contract = SmartContract::new("
            fun attack(target: Address) {
                target.call(\"withdraw\", []);
            }
        ");
        
        let victim_contract = SmartContract::new("
            var balance: i32 = 1000;
            
            fun withdraw() {
                if balance > 0 {
                    let amount = balance;
                    // Vulnerable point: external call before state update
                    msg.sender.call(\"receive\", [amount]);
                    balance = 0; // This happens after external call
                }
            }
        ");
        
        // Set up reentrancy attack
        let result = simulate_reentrancy_attack(attacker_contract, victim_contract);
        
        // Modern smart contract should have reentrancy protection
        assert!(result.prevented_reentrancy,
            "Reentrancy attacks should be prevented");
        
        // Balance should only be withdrawn once
        assert_eq!(victim_contract.get_balance(), 0);
        assert_eq!(get_total_withdrawn(), 1000); // Not 2000 from double withdrawal
    }
    
    // ============================================================
    // Fork Resolution Scenarios
    // ============================================================
    
    #[test]
    fun test_longest_chain_rule() {
        // Test fork resolution using longest chain rule
        let mut blockchain = Blockchain::new();
        
        // Create common prefix
        let genesis = blockchain.get_genesis_block();
        let block1 = create_valid_block(genesis.hash());
        let block2 = create_valid_block(block1.hash());
        
        blockchain.add_block(block1.clone());
        blockchain.add_block(block2.clone());
        
        // Create fork - two competing chains
        let fork_a_block3 = create_valid_block(block2.hash());
        let fork_a_block4 = create_valid_block(fork_a_block3.hash());
        
        let fork_b_block3 = create_valid_block(block2.hash());
        let fork_b_block4 = create_valid_block(fork_b_block3.hash());
        let fork_b_block5 = create_valid_block(fork_b_block4.hash());
        
        // Add fork A (shorter)
        blockchain.add_block(fork_a_block3);
        blockchain.add_block(fork_a_block4);
        
        let chain_a_length = blockchain.get_chain_length();
        
        // Add fork B (longer) - should cause reorganization
        blockchain.add_block(fork_b_block3);
        blockchain.add_block(fork_b_block4);
        blockchain.add_block(fork_b_block5);
        
        let chain_b_length = blockchain.get_chain_length();
        
        // Longest chain should win
        assert!(chain_b_length > chain_a_length,
            "Fork B should be longer than Fork A");
        
        // Active chain should be Fork B
        let active_tip = blockchain.get_chain_tip();
        assert_eq!(active_tip.hash(), fork_b_block5.hash(),
            "Active chain should switch to longest fork");
    }
    
    #[test]
    fun test_orphan_block_handling() {
        // Test handling of orphaned blocks
        let mut blockchain = Blockchain::new();
        
        // Add some blocks
        let block1 = create_valid_block(blockchain.get_genesis_hash());
        let block2 = create_valid_block(block1.hash());
        
        blockchain.add_block(block1.clone());
        blockchain.add_block(block2.clone());
        
        // Create competing fork that becomes longer
        let competing_block2 = create_valid_block(block1.hash());
        let competing_block3 = create_valid_block(competing_block2.hash());
        let competing_block4 = create_valid_block(competing_block3.hash());
        
        blockchain.add_block(competing_block2);
        blockchain.add_block(competing_block3);
        blockchain.add_block(competing_block4);
        
        // Original block2 should now be orphaned
        assert!(blockchain.is_orphaned(block2.hash()),
            "Original block2 should be orphaned after reorganization");
        
        // Orphaned block should not be in active chain
        assert!(!blockchain.is_in_active_chain(block2.hash()),
            "Orphaned block should not be in active chain");
        
        // But should still be stored for potential future reorganizations
        assert!(blockchain.has_block(block2.hash()),
            "Orphaned block should still be stored");
    }
    
    #[test]
    fun test_deep_reorganization_limits() {
        // Test limits on deep chain reorganizations
        let mut blockchain = Blockchain::new();
        
        // Build a long chain (100 blocks)
        let mut current_hash = blockchain.get_genesis_hash();
        for _ in 0..100 {
            let block = create_valid_block(current_hash);
            current_hash = block.hash();
            blockchain.add_block(block);
        }
        
        let original_tip = blockchain.get_chain_tip();
        
        // Try to create competing fork from very deep point
        let deep_point = blockchain.get_block_at_height(10).unwrap();
        let mut competing_hash = deep_point.hash();
        
        // Create slightly longer competing chain
        for _ in 0..92 { // 91 blocks + 1 extra = 92 > 90 remaining blocks
            let competing_block = create_valid_block(competing_hash);
            competing_hash = competing_block.hash();
            blockchain.add_block(competing_block);
        }
        
        // Should reject deep reorganization if beyond safety limit
        let reorg_limit = blockchain.get_max_reorg_depth();
        if 90 > reorg_limit {
            // Deep reorganization should be rejected
            let current_tip = blockchain.get_chain_tip();
            assert_eq!(current_tip.hash(), original_tip.hash(),
                "Very deep reorganizations should be rejected for safety");
        }
    }
    
    // ============================================================
    // Byzantine Fault Tolerance Tests
    // ============================================================
    
    #[test]
    fun test_byzantine_fault_tolerance() {
        // Test Byzantine fault tolerance with up to f faulty nodes
        let total_nodes = 10;
        let faulty_nodes = 3; // f = 3, need 3f + 1 = 10 total nodes
        
        let mut network = BlockchainNetwork::new(total_nodes);
        
        // Mark some nodes as Byzantine (malicious)
        for i in 0..faulty_nodes {
            network.set_node_byzantine(i, true);
        }
        
        // Honest nodes propose valid block
        let valid_block = create_valid_block(network.get_last_hash());
        
        // Byzantine nodes propose invalid blocks
        let mut byzantine_blocks = Vec::new();
        for i in 0..faulty_nodes {
            let invalid_block = create_invalid_block(network.get_last_hash(), i);
            byzantine_blocks.push(invalid_block);
        }
        
        // Run consensus protocol
        let consensus_result = network.run_consensus_round(
            vec![valid_block.clone()], // Honest proposals
            byzantine_blocks // Byzantine proposals
        );
        
        // Should reach consensus on valid block
        assert!(consensus_result.reached_consensus(),
            "Should reach consensus despite Byzantine nodes");
        
        assert_eq!(consensus_result.chosen_block(), valid_block,
            "Should choose valid block over invalid ones");
        
        // Safety: no two honest nodes accept different blocks
        let honest_decisions = network.get_honest_node_decisions();
        for decision in &honest_decisions {
            assert_eq!(*decision, valid_block,
                "All honest nodes should agree on same block");
        }
    }
    
    #[test]
    fun test_double_spending_prevention() {
        // Test prevention of double spending attacks
        let mut blockchain = Blockchain::new();
        
        // Create initial transaction: Alice has 100 coins
        let alice_address = Address::from_string("alice");
        let initial_tx = Transaction::coinbase(alice_address.clone(), 100);
        let block1 = Block::new(blockchain.get_last_hash(), vec![initial_tx]);
        blockchain.add_block(block1);
        
        // Alice tries to double spend: send same coins to both Bob and Charlie
        let bob_address = Address::from_string("bob");
        let charlie_address = Address::from_string("charlie");
        
        let tx_to_bob = Transaction::transfer(
            alice_address.clone(),
            bob_address.clone(),
            100, // All of Alice's coins
            0 // Transaction 0 (the coinbase)
        );
        
        let tx_to_charlie = Transaction::transfer(
            alice_address.clone(),
            charlie_address.clone(),
            100, // Same coins!
            0 // Same input transaction
        );
        
        // Try to include both transactions in same block
        let double_spend_block = Block::new(
            blockchain.get_last_hash(),
            vec![tx_to_bob.clone(), tx_to_charlie.clone()]
        );
        
        let result = blockchain.add_block(double_spend_block);
        
        // Block should be rejected due to double spending
        assert!(result.is_err(),
            "Block with double spending should be rejected");
        assert_eq!(result.unwrap_err(), BlockError::DoubleSpending);
        
        // Try to include in separate blocks (attack across blocks)
        let block2 = Block::new(blockchain.get_last_hash(), vec![tx_to_bob]);
        blockchain.add_block(block2).expect("First transaction should be valid");
        
        let block3 = Block::new(blockchain.get_last_hash(), vec![tx_to_charlie]);
        let result2 = blockchain.add_block(block3);
        
        // Second block should be rejected
        assert!(result2.is_err(),
            "Second transaction should be rejected as double spend");
    }
    
    #[test]
    fun test_nothing_at_stake_problem() {
        // Test solution to nothing-at-stake problem in proof-of-stake
        let mut pos_network = ProofOfStakeNetwork::new();
        
        // Set up validators with stakes
        pos_network.add_validator("validator1", 1000);
        pos_network.add_validator("validator2", 800);
        pos_network.add_validator("validator3", 600);
        
        // Create fork scenario
        let genesis = pos_network.get_genesis_block();
        let block1 = create_valid_pos_block(genesis.hash(), "validator1");
        
        // Fork: two competing blocks
        let fork_a = create_valid_pos_block(block1.hash(), "validator2");
        let fork_b = create_valid_pos_block(block1.hash(), "validator3");
        
        // Validators should not vote on both forks (slashing condition)
        let validator2_vote_a = pos_network.vote("validator2", fork_a.hash());
        let validator2_vote_b = pos_network.vote("validator2", fork_b.hash());
        
        // Should detect double voting
        let slashing_result = pos_network.check_slashing_conditions("validator2");
        
        assert!(slashing_result.should_slash,
            "Double voting should trigger slashing");
        
        // Validator should lose stake
        let original_stake = 800;
        let new_stake = pos_network.get_validator_stake("validator2");
        assert!(new_stake < original_stake,
            "Validator should lose stake for double voting");
    }
    
    // ============================================================
    // Cryptographic Edge Cases
    // ============================================================
    
    #[test]
    fun test_hash_collision_resistance() {
        // Test hash function collision resistance
        let hash_function = SHA256::new();
        let mut seen_hashes = HashMap::new();
        
        // Generate many different inputs
        for i in 0..10000 {
            let input = format!("test_input_{}", i);
            let hash = hash_function.hash(input.as_bytes());
            
            // Check for collisions
            if let Some(previous_input) = seen_hashes.get(&hash) {
                panic!("Hash collision found: '{}' and '{}' have same hash",
                    previous_input, input);
            }
            
            seen_hashes.insert(hash, input);
        }
        
        // No collisions should be found in practice
        assert_eq!(seen_hashes.len(), 10000,
            "Should have 10000 unique hashes");
    }
    
    #[test]
    fun test_digital_signature_security() {
        // Test digital signature security properties
        let keypair = KeyPair::generate();
        let message = "Important blockchain transaction";
        
        // Test 1: Valid signature verification
        let signature = keypair.sign(message.as_bytes());
        assert!(keypair.verify(message.as_bytes(), &signature),
            "Valid signature should verify correctly");
        
        // Test 2: Invalid signature rejection
        let wrong_message = "Different message";
        assert!(!keypair.verify(wrong_message.as_bytes(), &signature),
            "Signature should not verify for different message");
        
        // Test 3: Signature forgery resistance
        let attacker_keypair = KeyPair::generate();
        assert!(!attacker_keypair.verify(message.as_bytes(), &signature),
            "Signature should not verify with wrong public key");
        
        // Test 4: Signature malleability resistance
        let malleated_signature = signature.malleate();
        assert!(!keypair.verify(message.as_bytes(), &malleated_signature),
            "Malleated signature should be rejected");
    }
    
    #[test]
    fun test_merkle_tree_integrity() {
        // Test Merkle tree integrity properties
        let transactions = vec![
            "tx1: Alice -> Bob 10",
            "tx2: Bob -> Charlie 5", 
            "tx3: Charlie -> Dave 3",
            "tx4: Dave -> Eve 2"
        ];
        
        let merkle_tree = MerkleTree::from_transactions(&transactions);
        let root_hash = merkle_tree.get_root();
        
        // Test 1: Proof verification
        for (i, tx) in transactions.iter().enumerate() {
            let proof = merkle_tree.get_proof(i);
            assert!(merkle_tree.verify_proof(tx.as_bytes(), &proof, &root_hash),
                "Merkle proof should verify for transaction {}", i);
        }
        
        // Test 2: Invalid proof rejection
        let fake_tx = "tx5: Eve -> Frank 1";
        let fake_proof = merkle_tree.get_proof(0); // Use proof for different tx
        assert!(!merkle_tree.verify_proof(fake_tx.as_bytes(), &fake_proof, &root_hash),
            "Invalid Merkle proof should be rejected");
        
        // Test 3: Tree modification detection
        let mut modified_tree = merkle_tree.clone();
        modified_tree.replace_transaction(1, "tx2: Bob -> Mallory 100"); // Modified tx
        let modified_root = modified_tree.get_root();
        
        assert_ne!(root_hash, modified_root,
            "Tree modification should change root hash");
        
        // Original proofs should not work with modified root
        let original_proof = merkle_tree.get_proof(0);
        assert!(!merkle_tree.verify_proof(
            transactions[0].as_bytes(), 
            &original_proof, 
            &modified_root
        ), "Original proof should not verify against modified tree");
    }
    
    #[test]
    fun test_cryptographic_randomness() {
        // Test cryptographic randomness for nonce generation
        let mut nonces = HashMap::new();
        let iterations = 1000;
        
        for _ in 0..iterations {
            let nonce = generate_secure_nonce();
            
            // Check uniqueness
            assert!(!nonces.contains_key(&nonce),
                "Duplicate nonce detected: {}", nonce);
            
            nonces.insert(nonce, true);
            
            // Check entropy (basic statistical test)
            let nonce_bytes = nonce.to_bytes();
            let ones = count_ones(&nonce_bytes);
            let total_bits = nonce_bytes.len() * 8;
            let ratio = ones as f64 / total_bits as f64;
            
            // Should be roughly 50% ones and 50% zeros
            assert!(ratio > 0.4 && ratio < 0.6,
                "Nonce appears to have low entropy: {} ones out of {} bits", 
                ones, total_bits);
        }
    }
    
    // ============================================================
    // Network Security Tests
    // ============================================================
    
    #[test]
    fun test_sybil_attack_resistance() {
        // Test resistance to Sybil attacks
        let mut network = BlockchainNetwork::new(100);
        
        // Attacker creates many identities
        let attacker_nodes = 60;
        for i in 0..attacker_nodes {
            let sybil_id = format!("sybil_{}", i);
            network.add_node(sybil_id);
        }
        
        // All Sybil nodes controlled by same entity
        network.mark_nodes_as_sybil(0..attacker_nodes);
        
        // Run consensus with Sybil resistance mechanism
        let honest_proposal = create_valid_block(network.get_last_hash());
        let sybil_proposal = create_malicious_block(network.get_last_hash());
        
        let result = network.run_consensus_with_sybil_resistance(
            honest_proposal,
            sybil_proposal
        );
        
        // Should detect Sybil attack and maintain security
        assert!(result.detected_sybil_attack(),
            "Should detect Sybil attack");
        
        // Honest proposal should win despite numerical disadvantage
        assert_eq!(result.chosen_block(), honest_proposal,
            "Honest proposal should win despite Sybil nodes");
    }
    
    #[test]
    fun test_eclipse_attack_prevention() {
        // Test prevention of eclipse attacks
        let victim_node = BlockchainNode::new("victim");
        let attacker_nodes: Vec<_> = (0..20)
            .map(|i| BlockchainNode::new(&format!("attacker_{}", i)))
            .collect();
        
        // Attacker tries to isolate victim node
        for attacker in &attacker_nodes {
            victim_node.add_peer(attacker.get_address());
        }
        
        // Victim should maintain connections to diverse set of peers
        let peer_diversity = victim_node.check_peer_diversity();
        assert!(peer_diversity.is_sufficient(),
            "Node should maintain diverse peer connections");
        
        // Victim should detect if all peers are controlled by same entity
        let eclipse_detection = victim_node.detect_eclipse_attack();
        if attacker_nodes.len() >= victim_node.get_max_peers() {
            assert!(eclipse_detection.possible_eclipse,
                "Should detect potential eclipse attack");
        }
        
        // Victim should seek additional peer connections
        let mitigation_result = victim_node.mitigate_eclipse_risk();
        assert!(mitigation_result.sought_new_peers,
            "Should actively seek new peer connections");
    }
    
    #[test]
    fun test_ddos_resistance() {
        // Test DDoS attack resistance
        let mut node = BlockchainNode::new("target");
        node.set_rate_limiting(true);
        
        // Simulate DDoS attack
        let attack_requests_per_second = 10000;
        let attack_duration = 10; // seconds
        
        let mut successful_requests = 0;
        let start_time = SystemTime::now();
        
        while start_time.elapsed().unwrap().as_secs() < attack_duration {
            // Rapid-fire requests
            for _ in 0..attack_requests_per_second {
                let request = create_spam_request();
                let response = node.handle_request(request);
                
                if response.is_ok() {
                    successful_requests += 1;
                }
            }
        }
        
        // Rate limiting should prevent overwhelming the node
        let max_expected = node.get_rate_limit() * attack_duration;
        assert!(successful_requests <= max_expected,
            "Rate limiting should prevent DDoS: {} requests succeeded", 
            successful_requests);
        
        // Node should remain responsive to legitimate requests
        let legitimate_request = create_legitimate_request();
        let response = node.handle_request(legitimate_request);
        assert!(response.is_ok() || response.unwrap_err() == NodeError::RateLimited,
            "Node should remain somewhat responsive during DDoS");
    }
}

// ============================================================
// Helper Functions and Structures
// ============================================================

struct Blockchain {
    blocks: Vec<Block>,
    difficulty: u32,
}

impl Blockchain {
    fun new() -> Self {
        Self {
            blocks: vec![Block::genesis()],
            difficulty: 1,
        }
    }
    
    fun add_block(&mut self, block: Block) -> Result<(), BlockError> {
        if self.validate_block(&block) {
            self.blocks.push(block);
            Ok(())
        } else {
            Err(BlockError::Invalid)
        }
    }
    
    fun validate_block(&self, block: &Block) -> bool {
        // Validate block hash, previous hash, transactions, etc.
        block.is_valid() && 
        block.previous_hash() == self.get_last_hash() &&
        self.validate_transactions(block.transactions())
    }
    
    fun validate_transactions(&self, transactions: &[Transaction]) -> bool {
        // Check for double spending, valid signatures, etc.
        let mut used_outputs = std::collections::HashSet::new();
        
        for tx in transactions {
            for input in tx.inputs() {
                let output_ref = (input.tx_hash(), input.output_index());
                if used_outputs.contains(&output_ref) {
                    return false; // Double spending detected
                }
                used_outputs.insert(output_ref);
            }
        }
        
        true
    }
    
    fun get_last_hash(&self) -> Hash {
        self.blocks.last().unwrap().hash()
    }
    
    fun adjust_difficulty(&mut self) -> u32 {
        // Simple difficulty adjustment algorithm
        let target_time = 600; // 10 minutes
        let adjustment_period = 4; // Adjust every 4 blocks
        
        if self.blocks.len() < adjustment_period {
            return self.difficulty;
        }
        
        let recent_blocks = &self.blocks[self.blocks.len() - adjustment_period..];
        let time_taken = recent_blocks.last().unwrap().timestamp() - 
                        recent_blocks.first().unwrap().timestamp();
        
        let expected_time = target_time * (adjustment_period - 1);
        let adjustment_factor = expected_time as f64 / time_taken as f64;
        
        // Bound adjustment factor between 0.25 and 4.0
        let bounded_factor = adjustment_factor.max(0.25).min(4.0);
        
        self.difficulty = ((self.difficulty as f64 * bounded_factor) as u32).max(1);
        self.difficulty
    }
    
    fun get_previous_difficulty(&self) -> u32 {
        self.difficulty // Simplified - would track history in real implementation
    }
}

// Placeholder structures
struct Block;
struct Transaction;
struct Hash;
struct Address;
struct SmartContract;
struct ContractInput;
struct KeyPair;
struct MerkleTree;
struct BlockchainNetwork;
struct BlockchainNode;

// Placeholder enums
enum BlockError {
    Invalid,
    DoubleSpending,
}

enum ContractError {
    OutOfGas,
}

enum NodeError {
    RateLimited,
}

// Helper functions would be implemented here...
fun create_test_block(prev_hash: Hash, timestamp: SystemTime) -> Block {
    // Implementation would create a test block
    Block
}

fun create_valid_block(prev_hash: Hash) -> Block {
    // Implementation would create a valid block
    Block
}

fun get_current_stack_size() -> usize { 1024 }
const MAX_STACK_SIZE: usize = 8192;

fun create_legitimate_request() -> Request { Request }
fun create_spam_request() -> Request { Request }

struct Request;

// Additional helper implementations would go here...