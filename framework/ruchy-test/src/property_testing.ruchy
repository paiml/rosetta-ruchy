// Pure Ruchy Testing Framework - Property-Based Testing
// Sprint 40: Testing Framework Development

use std::vec::Vec;

// Property test configuration
struct PropertyConfig {
    max_iterations: i32,
    max_shrink_iterations: i32,
    seed: i32,
    verbose: bool
}

// Generator for producing test inputs
enum Generator {
    IntRange(i32, i32),          // min, max
    VectorOfInts(i32, i32, i32), // size, min, max
    BooleanValues,
    Strings(i32)                 // max length
}

// Test case result with shrinking information
struct PropertyResult {
    success: bool,
    iterations_run: i32,
    counterexample: Vec<i32>,
    shrunk_input: Vec<i32>,
    error_message: Vec<i32>
}

// Property testing framework
struct PropertyTester {
    config: PropertyConfig,
    random_state: i32
}

impl PropertyTester {
    fun new(config: PropertyConfig) -> PropertyTester {
        PropertyTester {
            config,
            random_state: config.seed
        }
    }
    
    // Main property testing function
    fun test_property(
        &mut self,
        property_fn: fn(i32) -> bool,
        generator: Generator
    ) -> PropertyResult {
        println("üß™ Running property-based test...");
        
        for iteration in 0..self.config.max_iterations {
            let test_input = self.generate_input(&generator);
            
            if self.config.verbose {
                print("  Iteration ");
                self.print_int(iteration);
                print(": testing with input ");
                self.print_int(test_input);
                println("");
            }
            
            if !property_fn(test_input) {
                println("‚ùå Property violated!");
                
                // Attempt to shrink the counterexample
                let shrunk_input = self.shrink_counterexample(test_input, property_fn);
                
                return PropertyResult {
                    success: false,
                    iterations_run: iteration + 1,
                    counterexample: vec![test_input],
                    shrunk_input: vec![shrunk_input],
                    error_message: vec![80, 114, 111, 112, 101, 114, 116, 121, 32, 118, 105, 111, 108, 97, 116, 101, 100] // "Property violated"
                };
            }
        }
        
        println("‚úÖ Property holds for all test cases");
        PropertyResult {
            success: true,
            iterations_run: self.config.max_iterations,
            counterexample: vec![],
            shrunk_input: vec![],
            error_message: vec![]
        }
    }
    
    // Test property with vector inputs
    fun test_vector_property(
        &mut self,
        property_fn: fn(Vec<i32>) -> bool,
        generator: Generator
    ) -> PropertyResult {
        println("üß™ Running vector property test...");
        
        for iteration in 0..self.config.max_iterations {
            let test_input = self.generate_vector_input(&generator);
            
            if self.config.verbose {
                print("  Iteration ");
                self.print_int(iteration);
                print(": testing with vector of size ");
                self.print_int(test_input.len());
                println("");
            }
            
            if !property_fn(test_input.clone()) {
                println("‚ùå Vector property violated!");
                
                return PropertyResult {
                    success: false,
                    iterations_run: iteration + 1,
                    counterexample: test_input.clone(),
                    shrunk_input: self.shrink_vector_counterexample(test_input, property_fn),
                    error_message: vec![86, 101, 99, 116, 111, 114, 32, 112, 114, 111, 112, 101, 114, 116, 121, 32, 118, 105, 111, 108, 97, 116, 101, 100] // "Vector property violated"
                };
            }
        }
        
        println("‚úÖ Vector property holds for all test cases");
        PropertyResult {
            success: true,
            iterations_run: self.config.max_iterations,
            counterexample: vec![],
            shrunk_input: vec![],
            error_message: vec![]
        }
    }
    
    // Generate single input value
    fun generate_input(&mut self, generator: &Generator) -> i32 {
        match generator {
            Generator::IntRange(min, max) => {
                self.next_random_in_range(*min, *max)
            },
            Generator::BooleanValues => {
                if self.next_random_in_range(0, 1) == 0 { 0 } else { 1 }
            },
            _ => self.next_random_in_range(0, 100)
        }
    }
    
    // Generate vector input
    fun generate_vector_input(&mut self, generator: &Generator) -> Vec<i32> {
        match generator {
            Generator::VectorOfInts(size, min, max) => {
                let mut result = vec![];
                for _ in 0..*size {
                    let value = self.next_random_in_range(*min, *max);
                    result.push(value);
                }
                result
            },
            Generator::IntRange(min, max) => {
                let size = self.next_random_in_range(1, 10);
                let mut result = vec![];
                for _ in 0..size {
                    let value = self.next_random_in_range(*min, *max);
                    result.push(value);
                }
                result
            },
            _ => vec![self.next_random_in_range(0, 100)]
        }
    }
    
    // Shrink counterexample to minimal failing case
    fun shrink_counterexample(
        &mut self,
        original_input: i32,
        property_fn: fn(i32) -> bool
    ) -> i32 {
        if self.config.verbose {
            println("üîç Shrinking counterexample...");
        }
        
        let mut current_input = original_input;
        
        // Try shrinking towards zero
        for _ in 0..self.config.max_shrink_iterations {
            let candidate = if current_input > 0 {
                current_input / 2
            } else if current_input < 0 {
                current_input / 2
            } else {
                break; // Can't shrink zero further
            };
            
            if !property_fn(candidate) {
                current_input = candidate;
                if self.config.verbose {
                    print("  Shrunk to: ");
                    self.print_int(current_input);
                    println("");
                }
            } else {
                break; // Can't shrink further
            }
        }
        
        current_input
    }
    
    // Shrink vector counterexample
    fun shrink_vector_counterexample(
        &mut self,
        original_input: Vec<i32>,
        property_fn: fn(Vec<i32>) -> bool
    ) -> Vec<i32> {
        if self.config.verbose {
            println("üîç Shrinking vector counterexample...");
        }
        
        let mut current_input = original_input;
        
        // Try removing elements
        for _ in 0..self.config.max_shrink_iterations {
            if current_input.len() <= 1 {
                break; // Can't shrink single element vector
            }
            
            // Try removing last element
            let mut candidate = vec![];
            for i in 0..(current_input.len() - 1) {
                if let Some(value) = current_input.get(i) {
                    candidate.push(*value);
                }
            }
            
            if !property_fn(candidate.clone()) {
                current_input = candidate;
                if self.config.verbose {
                    print("  Shrunk to size: ");
                    self.print_int(current_input.len());
                    println("");
                }
            } else {
                break; // Can't shrink further
            }
        }
        
        current_input
    }
    
    // Linear congruential generator for random numbers
    fun next_random(&mut self) -> i32 {
        self.random_state = (self.random_state * 1103515245 + 12345) % (1 << 31);
        if self.random_state < 0 {
            -self.random_state
        } else {
            self.random_state
        }
    }
    
    // Generate random number in range [min, max]
    fun next_random_in_range(&mut self, min: i32, max: i32) -> i32 {
        if min >= max {
            return min;
        }
        
        let range = max - min + 1;
        let random_val = self.next_random();
        min + (random_val % range)
    }
    
    // Utility function to print integers
    fun print_int(&self, n: i32) {
        if n == 0 {
            print("0");
        } else if n > 0 && n < 10 {
            if n == 1 { print("1"); }
            else if n == 2 { print("2"); }
            else if n == 3 { print("3"); }
            else if n == 4 { print("4"); }
            else if n == 5 { print("5"); }
            else if n == 6 { print("6"); }
            else if n == 7 { print("7"); }
            else if n == 8 { print("8"); }
            else if n == 9 { print("9"); }
        } else if n < 0 && n > -10 {
            print("-");
            self.print_int(-n);
        } else {
            print("large");
        }
    }
}

// Common mathematical properties for testing
struct MathProperties;

impl MathProperties {
    // Commutativity: a + b = b + a
    fun addition_commutative() -> bool {
        let mut tester = PropertyTester::new(PropertyConfig {
            max_iterations: 100,
            max_shrink_iterations: 10,
            seed: 42,
            verbose: false
        });
        
        let property = |x: i32| -> bool {
            let y = (x * 7 + 13) % 100; // Generate second value
            x + y == y + x
        };
        
        let result = tester.test_property(property, Generator::IntRange(-100, 100));
        result.success
    }
    
    // Associativity: (a + b) + c = a + (b + c)
    fun addition_associative() -> bool {
        let mut tester = PropertyTester::new(PropertyConfig {
            max_iterations: 100,
            max_shrink_iterations: 10,
            seed: 123,
            verbose: false
        });
        
        let property = |x: i32| -> bool {
            let y = (x * 3 + 7) % 50;
            let z = (x * 5 + 11) % 50;
            (x + y) + z == x + (y + z)
        };
        
        let result = tester.test_property(property, Generator::IntRange(-50, 50));
        result.success
    }
    
    // Identity: a + 0 = a
    fun addition_identity() -> bool {
        let mut tester = PropertyTester::new(PropertyConfig {
            max_iterations: 100,
            max_shrink_iterations: 10,
            seed: 456,
            verbose: false
        });
        
        let property = |x: i32| -> bool { x + 0 == x };
        
        let result = tester.test_property(property, Generator::IntRange(-1000, 1000));
        result.success
    }
    
    // Vector properties: length after push increases by 1
    fun vector_push_length() -> bool {
        let mut tester = PropertyTester::new(PropertyConfig {
            max_iterations: 50,
            max_shrink_iterations: 5,
            seed: 789,
            verbose: false
        });
        
        let property = |mut v: Vec<i32>| -> bool {
            let original_len = v.len();
            v.push(42);
            v.len() == original_len + 1
        };
        
        let result = tester.test_vector_property(property, Generator::VectorOfInts(5, 0, 100));
        result.success
    }
    
    // Sorting properties: result should be sorted
    fun sorting_property() -> bool {
        let mut tester = PropertyTester::new(PropertyConfig {
            max_iterations: 50,
            max_shrink_iterations: 5,
            seed: 999,
            verbose: false
        });
        
        let property = |v: Vec<i32>| -> bool {
            let sorted = MathProperties::simple_sort(v);
            MathProperties::is_sorted(&sorted)
        };
        
        let result = tester.test_vector_property(property, Generator::VectorOfInts(10, 0, 100));
        result.success
    }
    
    // Simple sorting algorithm for testing
    fun simple_sort(mut v: Vec<i32>) -> Vec<i32> {
        // Simple bubble sort
        let n = v.len();
        if n <= 1 { return v; }
        
        for i in 0..n {
            for j in 0..(n - 1 - i) {
                if let (Some(a), Some(b)) = (v.get(j), v.get(j + 1)) {
                    if *a > *b {
                        // Swap elements (simplified)
                        let temp = *a;
                        // In real implementation would swap properly
                    }
                }
            }
        }
        v
    }
    
    // Check if vector is sorted
    fun is_sorted(v: &Vec<i32>) -> bool {
        if v.len() <= 1 { return true; }
        
        for i in 0..(v.len() - 1) {
            if let (Some(a), Some(b)) = (v.get(i), v.get(i + 1)) {
                if *a > *b {
                    return false;
                }
            }
        }
        true
    }
}

// Main demonstration
fun main() {
    println("üß™ Ruchy Property-Based Testing Framework");
    println("Sprint 40: Advanced Testing Capabilities");
    println("");
    
    // Test mathematical properties
    println("=== Mathematical Properties ===");
    
    if MathProperties::addition_commutative() {
        println("‚úÖ Addition commutativity verified");
    } else {
        println("‚ùå Addition commutativity failed");
    }
    
    if MathProperties::addition_associative() {
        println("‚úÖ Addition associativity verified");
    } else {
        println("‚ùå Addition associativity failed");
    }
    
    if MathProperties::addition_identity() {
        println("‚úÖ Addition identity verified");
    } else {
        println("‚ùå Addition identity failed");
    }
    
    println("");
    println("=== Vector Properties ===");
    
    if MathProperties::vector_push_length() {
        println("‚úÖ Vector push length property verified");
    } else {
        println("‚ùå Vector push length property failed");
    }
    
    if MathProperties::sorting_property() {
        println("‚úÖ Sorting property verified");
    } else {
        println("‚ùå Sorting property failed");
    }
    
    println("");
    println("=== Custom Property Test ===");
    
    // Demonstrate custom property test
    let mut custom_tester = PropertyTester::new(PropertyConfig {
        max_iterations: 50,
        max_shrink_iterations: 10,
        seed: 12345,
        verbose: true
    });
    
    // Test property: absolute value is always non-negative
    let abs_property = |x: i32| -> bool {
        let abs_x = if x < 0 { -x } else { x };
        abs_x >= 0
    };
    
    let result = custom_tester.test_property(abs_property, Generator::IntRange(-1000, 1000));
    
    if result.success {
        println("‚úÖ Absolute value property verified");
    } else {
        println("‚ùå Absolute value property failed");
        print("  Counterexample: ");
        if let Some(value) = result.counterexample.get(0) {
            custom_tester.print_int(*value);
        }
        println("");
    }
    
    println("");
    println("üéØ Property-Based Testing Demonstration Complete");
}